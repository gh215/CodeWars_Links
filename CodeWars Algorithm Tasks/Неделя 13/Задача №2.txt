## Последовательность решения задачи

**Ссылка:** [Codewars Kata Review](https://www.codewars.com/kata/reviews/57874987d9456ea80500019f/groups/67e6cef6ea99b2220d1b96e7)

---

### 1. Полностью понять, что требуется сделать в задаче

**Ответ:** Нам даётся две переменных - 'n' и 'p', два положительных числа. 
Нужно реализовать функцию, которая находит такое целое положительное число 'k', что сумма цифр 'n', 
возведенных в последовательные степени, начиная с числа 'p', равна "k * n". Если не получается найти 'k' таким образом - вернуть '-1'.

*   Пример: "n = 89', "p = 1" -> "8^1 + 9^2 = 8 + 81 = 89". Так как "89 = 1 * 89", то "k = 1".
*   Пример: "n = 92', "p = 1" -> "9^1 + 2^2 = 9 + 4 = 13". '13' не делится на '92' нацело. Возвращаем '-1'.
*   Пример: "n = 695', "p = 2" -> "6^2 + 9^3 + 5^4 = 36 + 729 + 625 = 1390". Так как "1390 = 2 * 695", то "k = 2".

---

### 2. Разбить задачу на подзадачи

**Ответ:**
1.  Разложить число 'n' на цифры (в правильном порядке).
2.  Подсчитать сумму цифр, последовательно возведенных в степень, начиная с 'p'.
3.  Проверить, делится ли полученная сумма на 'n' без остатка. Если да, найти частное ('k').
4.  Вернуть 'k', если оно целое положительное, иначе вернуть '-1'.

---

### 3. Написать псевдокод (функции, осн. переменные, прим. последовательность действий)

**Ответ:**

```cpp

#include <vector>
#include <string>
#include <cmath>

class DigPow
{
public:
  static std::vector<int> disassembleNumber(size_t n)
  {
    std::vector<int> result;
    while (n > 0)
    {
      result.push_back(n % 10);
      n /= 10;
    }
    
    std::reverse(result.begin(), result.end());
    
    return result;
  }
  
  static double sumDigitSeq(std::vector<int> seq, int p)
  {
    double result = 0;
    
    for (size_t i = 0; i < seq.size(); i++)
    {
      result += std::pow(seq[i], p + i);
    }
    
    return result;
  }
  
  static int digPow(int n, int p)
  {
    auto one = disassembleNumber(n);
    auto two = sumDigitSeq(one, p);
    
    double k = two / n;
    
    if (k == static_cast<int>(k)) return k;
    else return -1;   
  }
    
};

```
---

### 4. Реализовать функции

*   4.1. **Что должна делать функция?**
*   4.2. **Какие данные требуются?**
*   4.3. **Какие варианты входных данных могут быть?**
*   4.4. **Реализация тела функции.**
*   4.5. **Проверка и тестирование функции.**

**Ответ:**

**А) Функция 'getDigitsInOrder':**
*   4.1. Разбивает целое положительное число 'n' на отдельные цифры и возвращает их в виде 'правильного' вектора 'std::vector<int>', 
т.е. в том порядке, в котором они идут в числе.
*   4.2. Требуется одно целое число 'n'.
*   4.3. Положительное целое число 'n'. (Крайний случай: "n = 0" или однозначные числа).
*   4.4. **Сделано.** 
*   4.5. **Протестировано.** 

**Б) Функция 'calculateSumOfPowers':**
*   4.1. Принимает вектор цифр и начальную степень 'p'. Вычисляет сумму и возвращает результат типа 'double'.
*   4.2. Вектор цифр 'std::vector<int>' (результат 'getDigitsInOrder') и целое число 'p'.
*   4.3. Вектор с цифрами (от 0 до 9), положительное целое число 'p'. (Крайний случай: пустой вектор, "p = 0")
*   4.4. **Сделано.** 
*   4.5. **Протестировано.** 

**В) Функция 'digPow':**
*   4.1. Координирует работу: получает цифры числа 'n' с помощью 'getDigitsInOrder', вычисляет сумму степеней с помощью 'calculateSumOfPowers'. 
Проверяет, делится ли сумма на 'n'. Если да, возвращает частное 'k'. Иначе возвращает '-1'.
*   4.2. Исходные целые положительные числа 'n' и 'p'.
*   4.3. Положительные целые числа 'n' и 'p'. (Крайние случаи: "n = 1", "p = 1")
*   4.4. **Сделано.** 
*   4.5. **Протестировано.** 
---

### 5. Написание кода основной функции

**Ответ:** **Сделано. Протестировано.** (Реализация включена в шаг 3 и детализирована в шаге 4В).

---

### 6. Тестирование всей функции

**Ответ:** **Сделано. Протестировано.** 

---
